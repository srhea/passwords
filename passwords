#!/bin/sh
exec scala "$0" "$@"
!#

import java.io.{ ByteArrayInputStream, ByteArrayOutputStream }
import java.io.{ DataInputStream, DataOutputStream, File, FileInputStream, FileOutputStream }
import java.security.SecureRandom
import javax.crypto.{ Cipher, SecretKeyFactory }
import javax.crypto.spec.{ IvParameterSpec, PBEKeySpec, SecretKeySpec }
import scala.collection.mutable.ArrayBuffer

class Vault(password: Array[Char], salt: Array[Byte]) {
  val factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1")
  val spec = new PBEKeySpec(password, salt, 65536 /* iterations */, 256 /* key length */)
  val secret = new SecretKeySpec(factory.generateSecret(spec).getEncoded, "AES")

  def encrypt(plaintext: Array[Byte]) = {
    val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
    cipher.init(Cipher.ENCRYPT_MODE, secret)
    val iv = cipher.getParameters.getParameterSpec(classOf[IvParameterSpec]).getIV
    val ciphertext = cipher.doFinal(plaintext)
    (iv, ciphertext)
  }

  def decrypt(iv: Array[Byte], ciphertext: Array[Byte]) = {
    val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv))
    cipher.doFinal(ciphertext)
  }
}

case class SiteInfo(username: String, password: String)

class VaultFile(file: File, password: Array[Char]) {
  val Version = "1.0"
  val InfoString = "Passwords Version %s, https://github.com/srhea/passwords".format(Version)
  val Terminator = '\0'.toByte

  // Cribbed from Beginning Scala by David Pollack, pp. 109-112.
  def using[A <: {def close(): Unit}, B](a: A)(f: A => B): B = try { f(a) } finally { a.close() }

  def readBytes(is: DataInputStream) = {
    val length = is.readInt()
    val result = new Array[Byte](length)
    is.readFully(result, 0, length)
    result
  }

  def writeBytes(os: DataOutputStream, bytes: Array[Byte]) {
    os.writeInt(bytes.length)
    os.write(bytes)
  }

  def readPlaintext: Array[Byte] = {
    using(new DataInputStream(new FileInputStream(file))) { is =>
      def readLine(): String = {
        val buffer = new ArrayBuffer[Byte]
        while (true) {
          val byte = is.readByte()
          if (byte == Terminator)
            return new String(buffer.toArray, "UTF-8")
          buffer += byte
        }
        "" // unreachable
      }
      val infoString = readLine()
      """Passwords Version (\d+\.\d+)""".r.findFirstMatchIn(infoString) match {
        case None => sys.error("can't find version number in \"" + infoString + "\"")
        case Some(m) =>
          val version = m.group(1)
          if (version != Version)
            sys.error("unknown file version " + version + " in " + file.getPath)
      }
      val salt = readBytes(is)
      val iv = readBytes(is)
      val ciphertext = readBytes(is)
      val vault = new Vault(password, salt)
      vault.decrypt(iv, ciphertext)
    }
  }

  def writeCiphertext(plaintext: Array[Byte]) {
    using(new DataOutputStream(new FileOutputStream(file))) { os =>
      val rand = new SecureRandom
      val salt = new Array[Byte](16)
      rand.nextBytes(salt)
      val vault = new Vault(password, salt)
      val (iv, ciphertext) = vault.encrypt(plaintext)
      os.write(InfoString.getBytes("UTF-8"))
      os.write(Terminator)
      writeBytes(os, salt)
      writeBytes(os, iv)
      writeBytes(os, ciphertext)
    }
  }

  def read: Map[String, SiteInfo] = {
    using(new DataInputStream(new ByteArrayInputStream(readPlaintext))) { is =>
      def readString() = new String(readBytes(is), "UTF-8")
      val siteCount = is.readInt()
      (1 to siteCount).map { siteIndex =>
        val site = readString
        val username = readString
        val password = readString
        site -> SiteInfo(username, password)
      }.toMap
    }
  }

  def write(map: Map[String, SiteInfo]) {
    using(new ByteArrayOutputStream) { bs =>
      using(new DataOutputStream(bs)) { os =>
        def writeString(s: String) = writeBytes(os, s.getBytes("UTF-8"))
        os.writeInt(map.size)
        map.foreach { case (site, info) =>
          writeString(site)
          writeString(info.username)
          writeString(info.password)
        }
      }
      writeCiphertext(bs.toByteArray)
    }
  }
}

object Password {
  def generate(length: Int): String = {
    val Lowers = "abcdefghijklmnopqrstuvwxyz"
    val Uppers = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    val Digits = "0123456789"
    val Symbols = """`-=[]\;',./~!@#$%^&*()_+{}|:"<>?"""
    val Groups = Array(Lowers, Uppers, Digits, Symbols)
    val All = Groups.mkString("")

    val rand = new SecureRandom
    (1 to 100).foreach { attempt =>
      val result = (1 to length).map { i => All(rand.nextInt(All.length)) }.mkString("")
      val missing = Groups.filter { group => result.filter { c => group.contains(c) }.isEmpty }
      if (missing.isEmpty)
        return result
    }
    throw new Exception("failed to find a good password")
  }
}

def usage() {
  println("""|Usage:
             |  passwords generate [length]
             |  passwords lookup <search string>
             |  passwords set <site> <username>""".stripMargin)
  sys.exit(1)
}

val DefaultFile = new File(System.getProperty("user.home"), ".passwords")

if (args.length == 0)
  usage()

args.head match {
  case "generate" =>
    val length = if (args.length > 1) Integer.parseInt(args(1)) else 8
    if (length < 4)
      sys.error("length must be at least 4")
    println(Password.generate(length))
  case "lookup" =>
    if (args.length < 2)
      usage()
    val search = args(1)
    val password = System.console.readPassword("Master password: ")
    val vf = new VaultFile(DefaultFile, password)
    val matches = vf.read.filter { case (site, info) => site.contains(search) }
    if (matches.isEmpty)
      println("No passwords for sites matching \"%s\".".format(search))
    for ((site, info) <- matches) {
      println(site + " " + info.username + " " + info.password)
    }
  case "set" =>
    if (args.length < 3)
      usage()
    val site = args(1)
    val username = args(2)
    val masterPassword = System.console.readPassword("Master password: ")
    val vf = new VaultFile(DefaultFile, masterPassword)
    val map = if (DefaultFile.exists()) vf.read else Map[String, SiteInfo]()
    if (map.contains(site)) {
      val yn = System.console.readLine("Overwrite existing entry? (Y/N): ")
      if (!Array("y", "Y", "yes", "Yes").contains(yn))
        sys.exit(0)
    }
    val password = new String(System.console.readPassword("Password: "))
    vf.write(map + (site -> SiteInfo(username, password)))
  case _ => usage()
}
